#!/usr/bin/env node
'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toArray2 = require('babel-runtime/helpers/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var run = function () {
  var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(token) {
    var _this = this;

    var secrets, args, start, _ret, _list, theSecret, yes, secret, _elapsed, _secret, _elapsed2, _args3, rest, _args4, name, value_, value, _secret2, _elapsed3;

    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            secrets = new _secrets2.default(apiUrl, token, { debug: debug });
            args = argv._.slice(1);
            start = Date.now();

            if (!('ls' === subcommand || 'list' === subcommand)) {
              _context3.next = 8;
              break;
            }

            return _context3.delegateYield(_regenerator2.default.mark(function _callee2() {
              var list, elapsed, cur, out;
              return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!(0 !== args.length)) {
                        _context2.next = 3;
                        break;
                      }

                      (0, _error.error)('Invalid number of arguments. Usage: ' + _chalk2.default.cyan('`now secret ls`'));
                      return _context2.abrupt('return', {
                        v: exit(1)
                      });

                    case 3:
                      _context2.next = 5;
                      return secrets.ls();

                    case 5:
                      list = _context2.sent;
                      elapsed = (0, _ms2.default)(new Date() - start);

                      console.log('> ' + list.length + ' secret' + (list.length > 1 ? 's' : '') + ' found ' + _chalk2.default.gray('[' + elapsed + ']'));
                      cur = Date.now();
                      out = (0, _textTable2.default)(list.map(function (secret) {
                        return ['', secret.uid, _chalk2.default.bold(secret.name), _chalk2.default.gray((0, _ms2.default)(cur - new Date(secret.created)) + ' ago')];
                      }), { align: ['l', 'r', 'l'], hsep: ' '.repeat(2) });

                      if (out) console.log('\n' + out + '\n');
                      return _context2.abrupt('return', {
                        v: secrets.close()
                      });

                    case 12:
                    case 'end':
                      return _context2.stop();
                  }
                }
              }, _callee2, _this);
            })(), 't0', 5);

          case 5:
            _ret = _context3.t0;

            if (!((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object")) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt('return', _ret.v);

          case 8:
            if (!('rm' === subcommand || 'remove' === subcommand)) {
              _context3.next = 33;
              break;
            }

            if (!(1 !== args.length)) {
              _context3.next = 12;
              break;
            }

            (0, _error.error)('Invalid number of arguments. Usage: ' + _chalk2.default.cyan('`now secret rm <id | name>`'));
            return _context3.abrupt('return', exit(1));

          case 12:
            _context3.next = 14;
            return secrets.ls();

          case 14:
            _list = _context3.sent;
            theSecret = _list.filter(function (secret) {
              return secret.uid === args[0] || secret.name === args[0];
            })[0];

            if (!theSecret) {
              _context3.next = 25;
              break;
            }

            _context3.next = 19;
            return readConfirmation(theSecret);

          case 19:
            yes = _context3.sent;

            if (yes) {
              _context3.next = 23;
              break;
            }

            (0, _error.error)('User abort');
            return _context3.abrupt('return', exit(0));

          case 23:
            _context3.next = 27;
            break;

          case 25:
            (0, _error.error)('No secret found by id or name "' + args[0] + '"');
            return _context3.abrupt('return', exit(1));

          case 27:
            _context3.next = 29;
            return secrets.rm(args[0]);

          case 29:
            secret = _context3.sent;
            _elapsed = (0, _ms2.default)(new Date() - start);

            console.log(_chalk2.default.cyan('> Success!') + ' Secret ' + _chalk2.default.bold(secret.name) + ' ' + _chalk2.default.gray('(' + secret.uid + ')') + ' removed ' + _chalk2.default.gray('[' + _elapsed + ']'));
            return _context3.abrupt('return', secrets.close());

          case 33:
            if (!('rename' === subcommand)) {
              _context3.next = 43;
              break;
            }

            if (!(2 !== args.length)) {
              _context3.next = 37;
              break;
            }

            (0, _error.error)('Invalid number of arguments. Usage: ' + _chalk2.default.cyan('`now secret rename <old-name> <new-name>`'));
            return _context3.abrupt('return', exit(1));

          case 37:
            _context3.next = 39;
            return secrets.rename(args[0], args[1]);

          case 39:
            _secret = _context3.sent;
            _elapsed2 = (0, _ms2.default)(new Date() - start);

            console.log(_chalk2.default.cyan('> Success!') + ' Secret ' + _chalk2.default.bold(_secret.oldName) + ' ' + _chalk2.default.gray('(' + _secret.uid + ')') + ' renamed to ' + _chalk2.default.bold(args[1]) + ' ' + _chalk2.default.gray('[' + _elapsed2 + ']'));
            return _context3.abrupt('return', secrets.close());

          case 43:
            if (!('add' === subcommand || 'set' === subcommand)) {
              _context3.next = 59;
              break;
            }

            if (!(2 !== args.length)) {
              _context3.next = 48;
              break;
            }

            (0, _error.error)('Invalid number of arguments. Usage: ' + _chalk2.default.cyan('`now secret add <name> <value>`'));
            if (args.length > 2) {
              _args3 = (0, _toArray3.default)(args);
              rest = _args3.slice(1);

              console.log('> If your secret has spaces, make sure to wrap it in quotes. Example: \n' + ('  ' + _chalk2.default.cyan('$ now secret add ${args[0]} "${escaped}"') + ' '));
            }
            return _context3.abrupt('return', exit(1));

          case 48:
            _args4 = (0, _slicedToArray3.default)(args, 2);
            name = _args4[0];
            value_ = _args4[1];
            value = void 0;

            if (argv.base64) {
              value = { base64: value_ };
            } else {
              value = value_;
            }
            _context3.next = 55;
            return secrets.add(name, value);

          case 55:
            _secret2 = _context3.sent;
            _elapsed3 = (0, _ms2.default)(new Date() - start);

            console.log(_chalk2.default.cyan('> Success!') + ' Secret ' + _chalk2.default.bold(name) + ' ' + _chalk2.default.gray('(' + _secret2.uid + ')') + ' added ' + _chalk2.default.gray('[' + _elapsed3 + ']'));
            return _context3.abrupt('return', secrets.close());

          case 59:

            (0, _error.error)('Please specify a valid subcommand: ls | add | rename | rm');
            help();
            exit(1);

          case 62:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function run(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _textTable = require('text-table');

var _textTable2 = _interopRequireDefault(_textTable);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

var _cfg = require('../lib/cfg');

var cfg = _interopRequireWildcard(_cfg);

var _error = require('../lib/error');

var _secrets = require('../lib/secrets');

var _secrets2 = _interopRequireDefault(_secrets);

var _ms = require('ms');

var _ms2 = _interopRequireDefault(_ms);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var argv = (0, _minimist2.default)(process.argv.slice(2), {
  string: ['config', 'token'],
  boolean: ['help', 'debug', 'base64'],
  alias: {
    help: 'h',
    config: 'c',
    debug: 'd',
    base64: 'b',
    token: 't'
  }
});
var subcommand = argv._[0];

// options
var help = function help() {
  console.log('\n  ' + _chalk2.default.bold('ùö´ now secrets') + ' <ls | add | rename | rm> <secret>\n\n  ' + _chalk2.default.dim('Options:') + '\n\n    -h, --help              output usage information\n    -b, --base64            treat value as base64-encoded\n    -c ' + _chalk2.default.bold.underline('FILE') + ', --config=' + _chalk2.default.bold.underline('FILE') + '  config file\n    -d, --debug             debug mode [off]\n    -t ' + _chalk2.default.bold.underline('TOKEN') + ', --token=' + _chalk2.default.bold.underline('TOKEN') + ' login token\n\n  ' + _chalk2.default.dim('Examples:') + '\n\n  ' + _chalk2.default.gray('‚Äì') + ' Lists all your secrets:\n\n    ' + _chalk2.default.cyan('$ now secrets ls') + '\n\n  ' + _chalk2.default.gray('‚Äì') + ' Adds a new secret:\n\n    ' + _chalk2.default.cyan('$ now secrets add my-secret "my value"') + '\n\n    ' + _chalk2.default.gray('‚Äì') + ' Once added, a secret\'s value can\'t be retrieved in plaintext anymore\n    ' + _chalk2.default.gray('‚Äì') + ' If the secret\'s value is more than one word, wrap it in quotes\n    ' + _chalk2.default.gray('‚Äì') + ' Actually, when in doubt, wrap your value in quotes\n\n  ' + _chalk2.default.gray('‚Äì') + ' Exposes a secret as an env variable:\n\n    ' + _chalk2.default.cyan('$ now -e MY_SECRET=' + _chalk2.default.bold('@my-secret')) + '\n\n    Notice the ' + _chalk2.default.cyan.bold('`@`') + ' symbol which makes the value a secret reference.\n\n  ' + _chalk2.default.gray('‚Äì') + ' Renames a secret:\n\n    ' + _chalk2.default.cyan('$ now secrets rename my-secret my-renamed-secret') + '\n\n  ' + _chalk2.default.gray('‚Äì') + ' Removes a secret:\n\n    ' + _chalk2.default.cyan('$ now secrets rm my-secret') + '\n');
};

// options
var debug = argv.debug;
var apiUrl = argv.url || 'https://api.zeit.co';
if (argv.config) cfg.setConfigFile(argv.config);

var exit = function exit(code) {
  // we give stdout some time to flush out
  // because there's a node bug where
  // stdout writes are asynchronous
  // https://github.com/nodejs/node/issues/6456
  setTimeout(function () {
    return process.exit(code || 0);
  }, 100);
};

if (argv.help || !subcommand) {
  help();
  exit(0);
} else {
  var config = cfg.read();

  _promise2.default.resolve(argv.token || config.token || login(apiUrl)).then(function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(token) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return run(token);

            case 3:
              _context.next = 9;
              break;

            case 5:
              _context.prev = 5;
              _context.t0 = _context['catch'](0);

              (0, _error.handleError)(_context.t0);
              exit(1);

            case 9:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined, [[0, 5]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }()).catch(function (e) {
    (0, _error.error)('Authentication error ‚Äì ' + e.message);
    exit(1);
  });
}

process.on('uncaughtException', function (err) {
  (0, _error.handleError)(err);
  exit(1);
});

function readConfirmation(secret) {
  return new _promise2.default(function (resolve, reject) {
    var time = _chalk2.default.gray((0, _ms2.default)(new Date() - new Date(secret.created)) + ' ago');
    var tbl = (0, _textTable2.default)([[secret.uid, _chalk2.default.bold(secret.name), time]], { align: ['l', 'r', 'l'], hsep: ' '.repeat(6) });

    process.stdout.write('> The following secret will be removed permanently\n');
    process.stdout.write('  ' + tbl + '\n');

    process.stdout.write(_chalk2.default.bold.red('> Are you sure?') + ' ' + _chalk2.default.gray('[yN] '));

    process.stdin.on('data', function (d) {
      process.stdin.pause();
      resolve('y' === d.toString().trim().toLowerCase());
    }).resume();
  });
}